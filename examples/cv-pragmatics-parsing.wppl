/*
  Runs simple mode with particle filters so positions are somewhat freely chosen
  This uses images generated by a separate python script
   - available at iffsid.com/generate-images.py
   - the images generated need to go in assets/img/ in the compiled dippl setup
  needswork:
  1. definitely needs a beter distance metric, this one works incidentally
  2. spatial relations in ccg
 */

var multinomial = function(s, p) { return s[discrete(p)] }

    var makeObj = function() {
  return {//pos: multinomial([[100, 100], [100, 300], [300, 100], [300, 300]], [0.25, 0.25, 0.25, 0.25]),
    pos: [randomInteger(200), randomInteger(200)],
    blue: flip(0.5),
    square: flip(0.5)} // !blue = green; !square = triangle
}

var worldPrior = function(nObjLeft, meaningFn, worldSoFar, prevFactor) {
  var worldSoFar = worldSoFar == undefined ? [] : worldSoFar
  var prevFactor = prevFactor == undefined ? 0 : prevFactor
  if (nObjLeft == 0) {
    factor(-prevFactor)
    return worldSoFar
  } else {
    var newObj = makeObj()
    var newWorld = worldSoFar.concat([newObj])
    var newFactor = meaningFn(newWorld) ? 0 : -100
    factor(newFactor - prevFactor)
    return worldPrior(nObjLeft - 1, meaningFn, newWorld, newFactor)
  }
}

var meaning = function(utterance) {
  return combine_meanings(
      filter(map(utterance.split(' '), lexical_meaning),
      function(m) {return !(m.sem == undefined)}))
}

var lexical_meaning = function(word) {

  var wordMeanings = {
    'blue' : {
      sem: function(world) {return function(obj) {return obj.blue}},
      syn: {dir: 'L', int: 'NP', out: 'S'} },

    'green' : {
      sem: function(world) {return function(obj) {return !obj.blue}},
      syn: {dir: 'L', int: 'NP', out: 'S'} },

    'squares' : {
      sem: function(world) {return function(obj) {return obj.square}},
      syn: {dir: 'L', int: 'NP', out: 'S'} },

    'triangles' : {
      sem: function(world) {return function(obj) {return !obj.square}},
      syn: {dir: 'L', int: 'NP', out: 'S'} },

    'some' : {
      sem: function(world) {
        return function(P) {
          return function(Q) {
            return filter(filter(world, P), Q).length > 0}}},
      syn: {dir: 'R',
        int: {dir: 'L', int: 'NP', out: 'S'},
        out: {dir: 'R',
          int: {dir: 'L', int: 'NP', out: 'S'},
          out: 'S'}} },

    'all' : {
      sem: function(world) {
        return function(P) {
          return function(Q) {
            var first = filter(world, P)
            return first.length != 0 & filter(first, neg(Q)).length == 0}}},
      syn: {dir: 'R',
        int: {dir: 'L', int: 'NP', out: 'S'},
        out: {dir: 'R',
          int: {dir: 'L', int: 'NP', out: 'S'},
          out: 'S'}} },

    'none' : {
      sem: function(world) {
        return function(P) {
          return function(Q) {
            var first = filter(world, P)
            return first.length != 0 & filter(first, Q).length == 0}}},
      syn: {dir: 'R',
        int: {dir: 'L', int: 'NP', out: 'S'},
        out: {dir: 'R',
          int: {dir: 'L', int: 'NP', out: 'S'},
          out: 'S'}} },

    'not' : {
      sem: function(world) { return neg },
      syn: {dir: 'R',
        int: {dir: 'L', int: 'NP', out: 'S'},
        out: {dir: 'L', int: 'NP', out: 'S'} }
    }
  }

  var meaning = wordMeanings[word];
  return meaning == undefined ? {sem: undefined, syn: ''} :meaning;
}

var neg = function(Q) { return function(x) {return !Q(x)} }

    var applyWorldPassing = function(f, a) {
  return function(w) {return f(w)(a(w))}
}

var combine_meaning = function(meanings) {
  var possibleComb = canApply(meanings, 0)
  var i = possibleComb[randomInteger(possibleComb.length)]
  var s = meanings[i].syn
  if (s.dir == 'L') {
    var f = meanings[i].sem
    var a = meanings[i - 1].sem
    var newmeaning = {sem: applyWorldPassing(f, a), syn: s.out}
    return meanings.slice(0, i - 1).concat([newmeaning]).concat(meanings.slice(i + 1))
  }
  if (s.dir == 'R') {
    var f = meanings[i].sem
    var a = meanings[i + 1].sem
    var newmeaning = {sem: applyWorldPassing(f, a), syn: s.out}
    return meanings.slice(0, i).concat([newmeaning]).concat(meanings.slice(i + 2))
  }
}

//make a list of the indexes that can (syntactically) apply.
var canApply = function(meanings, i) {
  if (i == meanings.length) {
    return []
  }
  var s = meanings[i].syn
  if (s.hasOwnProperty('dir')) { //a functor
    var a = ((s.dir == 'L') ? syntaxMatch(s.int, meanings[i - 1].syn) : false) |
            ((s.dir == 'R') ? syntaxMatch(s.int, meanings[i + 1].syn) : false)
    if (a) {return [i].concat(canApply(meanings, i + 1))}
  }
  return canApply(meanings, i + 1)
}

// The syntaxMatch function is a simple recursion to
// check if two syntactic types are equal.
var syntaxMatch = function(s, t) {
  return !s.hasOwnProperty('dir') ? s == t :
      s.dir == t.dir & syntaxMatch(s.int, t.int) & syntaxMatch(s.out, t.out)
}

// Recursively do the above until only one meaning is
// left, return it's semantics.
var combine_meanings = function(meanings) {
  return (meanings.length == 1 ?
          meanings[0].sem : c
          ombine_meanings(combine_meaning(meanings)));
}

var utterancePrior = function() {
  var utterances = ['some of the squares are blue',
                    'all of the squares are blue',
                    'none of the squares are blue',
                    'some of the squares are green',
                    'all of the squares are green',
                    'none of the squares are green',
                    'some of the triangles are blue',
                    'all of the triangles are blue',
                    'none of the triangles are blue',
                    'some of the triangles are green',
                    'all of the triangles are green',
                    'none of the triangles are green']
  var i = randomInteger(utterances.length)
  return utterances[i]
}

var toInt = function(v) {return Math.floor(v)}

    var shapeCircumRadius = 20
var polygonVerts = function(n, nverts, at, ps) {
  var newps = ps.concat(
      [[toInt(at[0] + shapeCircumRadius * Math.cos(2 * Math.PI * n / nverts)),
        toInt(at[1] + shapeCircumRadius * Math.sin(2 * Math.PI * n / nverts))]]
      )
  return (n == 1) ? newps.concat([ps[0]]) : polygonVerts(n - 1, nverts, at, newps)
}

var drawPolygon = function(d, n, at, colour) {
  var fn = function(ps) {
    if (ps.length != 1) {
      d.line(ps[0][0], ps[0][1], ps[1][0], ps[1][1], 4, undefined, colour);
      fn(ps.slice(1));
    }
  }
  fn(polygonVerts(n, n, at, []))
}

var renderImg = function(imgObj, world) {
  var fn = function(w) {
    if (w.length != 0) {
      var colour = w[0].blue ? 'blue' : 'green'
      var nsides = w[0].square ? 4 : 3
      drawPolygon(imgObj, nsides, w[0].pos, colour)
      fn(w.slice(1))
    }
  }
  fn(world)
}

var literalListener = function(utterance) {
  ParticleFilter(function() {
    var m = meaning(utterance)
    var world = worldPrior(3, m)
    factor(m(world) ? 0 : -Infinity)
    return world
  }, 100)
}

var speaker = function(img) {
  ParticleFilter(function() {
    var utterance = utterancePrior()
    var L = literalListener(utterance)
    var newimg = Draw(200, 200, false)
    renderImg(img, sample(L))
    var newscore = -img.distance(newimg) / 1000
    //newimg.destroy()
    factor(newscore)
    return utterance
  }, 50)
}

// literalListener("all of the squares are blue")

var targetImage = Draw(200, 200, true);
loadImage(targetImage, '/assets/img/some_sq_blue.png')
print(speaker(targetImage))
